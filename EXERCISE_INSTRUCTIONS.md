# תרגיל פולימורפיזם - משחק שחמט

## מטרת התרגיל
התרגיל נועד להדגים ולהבין את מושג הפולימורפיזם (Polymorphism) ב-Java באמצעות יצירת משחק שחמט פשוט.

## דרישות התרגיל

### 1. יצירת מחלקה מופשטת (Abstract Class)
- **צרו מחלקה מופשטת `ChessPiece`** שתשמש כבסיס לכל כלי השחמט
- המחלקה תכיל:
  - שדות: מיקום, צבע (לבן/שחור), שם הכלי
  - מתודות מופשטות: `isValidMove()`, `getPossibleMoves()`, `getSymbol()`
  - מתודות קונקרטיות: `moveTo()`, `getPosition()`, `setPosition()`

### 2. יצירת מחלקות קונקרטיות
- **צרו מחלקה `Bishop`** (רץ) שמרחיבה את `ChessPiece`
- **צרו מחלקה `Knight`** (פרש) שמרחיבה את `ChessPiece`
- כל מחלקה תממש את המתודות המופשטות בהתאם לכללי התנועה שלה

### 3. מחלקת לוח השחמט
- **צרו מחלקה `ChessBoard`** שתנהל את כל הכלים
- המחלקה תכיל מערך של `ChessPiece` (הדגמת פולימורפיזם)
- מתודות נדרשות:
  - `addPiece()` - הוספת כלי ללוח
  - `removePiece()` - הסרת כלי מהלוח
  - `movePiece()` - הזזת כלי
  - `getPieceAt()` - קבלת כלי במיקום מסוים

### 4. מחלקת מיקום
- **צרו מחלקה `Position`** לניהול מיקומים על הלוח
- המחלקה תכיל: שורה ועמודה, מתודות getter/setter, בדיקת תקינות

### 5. מחלקה ראשית להדגמה
- **צרו מחלקה `ChessGame`** עם מתודה `main()`
- הדגימו את הפולימורפיזם:
  - יצירת כלים שונים
  - טיפול אחיד בכל הכלים
  - קריאה למתודות פולימורפיות

## דוגמאות לפולימורפיזם שצריכות להיות בקוד

### 1. טיפול אחיד באובייקטים שונים
```java
ChessPiece[] pieces = {new Bishop(...), new Knight(...)};
for (ChessPiece piece : pieces) {
    // אותה קריאה למתודה, התנהגות שונה
    Position[] moves = piece.getPossibleMoves();
}
```

### 2. זיהוי סוג בזמן ריצה
```java
if (piece instanceof Bishop) {
    Bishop bishop = (Bishop) piece;
    // שימוש במתודות ספציפיות לרץ
}
```

### 3. פולימורפיזם במתודות
```java
public boolean movePiece(ChessPiece piece, Position newPosition) {
    // כל כלי יודע לוודא את התנועה שלו
    if (piece.isValidMove(newPosition)) {
        piece.setPosition(newPosition);
        return true;
    }
    return false;
}
```

## כללי התנועה לכלי השחמט

### רץ (Bishop)
- תנועה אלכסונית בלבד
- מספר משבצות לא מוגבל
- לא יכול לדלג על כלים אחרים

### פרש (Knight)
- תנועה בצורת L (2 משבצות בכיוון אחד, 1 בכיוון הניצב)
- יכול לדלג על כלים אחרים
- 8 אפשרויות תנועה מכל מיקום

## מבנה הפרויקט הנדרש

```
OOP JAVA polymorpizm/
├── oopShayTavor/
│   └── ex2/
│       ├── ChessPiece.java      (מחלקה מופשטת)
│       ├── Bishop.java          (רץ)
│       ├── Knight.java          (פרש)
│       ├── Position.java        (מיקום)
│       ├── ChessBoard.java      (לוח שחמט)
│       └── ChessGame.java       (מחלקה ראשית)
├── README.md
└── compile_and_run.bat
```

## שלבי הביצוע

### שלב 1: יצירת המחלקה המופשטת
1. צרו את `ChessPiece` עם המתודות המופשטות
2. הוסיפו מתודות קונקרטיות משותפות
3. וודאו שהמחלקה לא ניתנת ליצירה ישירה

### שלב 2: יצירת מחלקות קונקרטיות
1. צרו את `Bishop` עם לוגיקת תנועה אלכסונית
2. צרו את `Knight` עם לוגיקת תנועה בצורת L
3. ממשו את כל המתודות המופשטות

### שלב 3: יצירת מחלקת הלוח
1. צרו את `ChessBoard` עם מערך של `ChessPiece`
2. הוסיפו מתודות לניהול הכלים
3. הדגימו פולימורפיזם במתודות

### שלב 4: יצירת מחלקת המיקום
1. צרו את `Position` עם שורה ועמודה
2. הוסיפו מתודות לבדיקת תקינות
3. ממשו `equals()` ו-`toString()`

### שלב 5: הדגמה
1. צרו את `ChessGame` עם `main()`
2. הדגימו יצירת כלים שונים
3. הדגימו טיפול אחיד בכל הכלים
4. הדגימו זיהוי סוג בזמן ריצה

## דרישות נוספות

### בדיקות נדרשות
- כל כלי יודע לוודא את התנועה שלו
- לוח השחמט מטפל בכל הכלים באופן אחיד
- ניתן להוסיף כלים חדשים בקלות
- הקוד נקי ומתועד

### תיעוד
- הוסיפו הערות לכל המתודות
- הסבירו את הפולימורפיזם בקוד
- צרו README מפורט

## הערות חשובות

1. **פולימורפיזם** = אותה קריאה למתודה, התנהגות שונה
2. **העברה אחידה** = טיפול בכל האובייקטים דרך הממשק המשותף
3. **זיהוי סוג** = שימוש ב-`instanceof` לזיהוי סוג ספציפי
4. **הרחבה** = הוספת כלים חדשים ללא שינוי בקוד הקיים

## ציון התרגיל

- **40%** - יישום נכון של המחלקה המופשטת
- **30%** - יישום נכון של המחלקות הקונקרטיות
- **20%** - הדגמת פולימורפיזם בקוד
- **10%** - תיעוד ואיכות הקוד

## הגשה

1. העלו את הפרויקט ל-GitHub
2. וודאו שהקוד מתקמפל ופועל
3. הוסיפו README מפורט
4. צרו דוגמה להרצה

**בהצלחה! 🎯**
